/* plank.vapi generated by valac 0.20.1.4-f5a54, do not modify. */

namespace Plank {
	namespace Drawing {
		[CCode (cheader_filename = "plank.h")]
		public abstract class AnimatedRenderer : GLib.Object {
			public AnimatedRenderer ();
			public void animated_draw ();
			protected abstract bool animation_needed (GLib.DateTime render_time);
			public void set_widget (Gtk.Widget widget);
			public AnimatedRenderer.with_widget (Gtk.Widget widget);
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockSurface : GLib.Object {
			public DockSurface (int width, int height);
			public Plank.Drawing.Color average_color ();
			public void clear ();
			public Plank.Drawing.DockSurface copy ();
			public Plank.Drawing.DockSurface create_mask (double threshold, out Gdk.Rectangle extent);
			public void exponential_blur (int radius);
			public void fast_blur (int radius, int process_count = 1);
			public void gaussian_blur (int radius);
			public Gdk.Pixbuf to_pixbuf ();
			public DockSurface.with_dock_surface (int width, int height, Plank.Drawing.DockSurface model);
			public DockSurface.with_internal (Cairo.ImageSurface image);
			public DockSurface.with_surface (int width, int height, Cairo.Surface model);
			public Cairo.Context Context { get; construct; }
			public int Height { get; construct; }
			public Cairo.Surface Internal { get; construct; }
			public int Width { get; construct; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockTheme : Plank.Drawing.Theme {
			public DockTheme (string name);
			public Plank.Drawing.DockSurface create_background (int width, int height, Gtk.PositionType position, Plank.Drawing.DockSurface model);
			public Plank.Drawing.DockSurface create_indicator (int size, Plank.Drawing.Color color, Plank.Drawing.DockSurface model);
			public Plank.Drawing.DockSurface create_urgent_glow (int size, Plank.Drawing.Color color, Plank.Drawing.DockSurface model);
			public void draw_active_glow (Plank.Drawing.DockSurface surface, Gdk.Rectangle clip_rect, Gdk.Rectangle rect, Plank.Drawing.Color color, double opacity, Gtk.PositionType pos);
			public void draw_item_count (Plank.Drawing.DockSurface surface, int icon_size, Plank.Drawing.Color color, int64 count);
			public void draw_item_progress (Plank.Drawing.DockSurface surface, int icon_size, Plank.Drawing.Color color, double progress);
			protected override void reset_properties ();
			protected override void verify (string prop);
			[Description (blurb = "The amount of time (in ms) for active window indicator animations.", nick = "active-time")]
			public int ActiveTime { get; set; }
			[Description (blurb = "The padding on the bottom dock edge, in tenths of a percent of IconSize.", nick = "top-padding")]
			public double BottomPadding { get; set; }
			[Description (blurb = "The amount of time (in ms) for click animations.", nick = "click-time")]
			public int ClickTime { get; set; }
			[Description (blurb = "The opacity value (0 to 1) to fade the dock to when hiding it.", nick = "fade-opacity")]
			public double FadeOpacity { get; set; }
			[Description (blurb = "The time (in ms) to fade the dock in/out on a hide (if FadeOpacity is < 1).", nick = "fade-time")]
			public int FadeTime { get; set; }
			[Description (blurb = "The time (in ms) of each pulse of the hidden-dock urgent glow.", nick = "glow-pulse-time")]
			public int GlowPulseTime { get; set; }
			[Description (blurb = "The size of the urgent glow (shown when dock is hidden), in tenths of a percent of IconSize.", nick = "glow-size")]
			public int GlowSize { get; set; }
			[Description (blurb = "The total time (in ms) to show the hidden-dock urgent glow.", nick = "glow-time")]
			public int GlowTime { get; set; }
			[Description (blurb = "The time (in ms) to slide the dock in/out on a hide (if FadeOpacity is 1).", nick = "hide-time")]
			public int HideTime { get; set; }
			[Description (blurb = "The padding on the left/right dock edges, in tenths of a percent of IconSize.", nick = "horizontal-padding")]
			public double HorizPadding { get; set; }
			[Description (blurb = "The size of the icon-shadow behind every item, in tenths of a percent of IconSize.", nick = "icon-shadow-size")]
			public double IconShadowSize { get; set; }
			[Description (blurb = "The size of item indicators, in tenths of a percent of IconSize.", nick = "indicator-size")]
			public double IndicatorSize { get; set; }
			[Description (blurb = "The padding between items on the dock, in tenths of a percent of IconSize.", nick = "item-padding")]
			public double ItemPadding { get; set; }
			[Description (blurb = "The height (in percent of IconSize) to bounce an icon when launching an application.", nick = "launch-bounce")]
			public double LaunchBounceHeight { get; set; }
			[Description (blurb = "The amount of time (in ms) to bounce an icon when launching an application.", nick = "launch-bounce-time")]
			public int LaunchBounceTime { get; set; }
			[Description (blurb = "The amount of time (in ms) to slide icons into/out of the dock.", nick = "slide-time")]
			public int SlideTime { get; set; }
			[Description (blurb = "The padding on the top dock edge, in tenths of a percent of IconSize.", nick = "top-padding")]
			public double TopPadding { get; set; }
			[Description (blurb = "The height (in percent of IconSize) to bounce an icon when the application sets urgent.", nick = "urgent-bounce")]
			public double UrgentBounceHeight { get; set; }
			[Description (blurb = "The amount of time (in ms) to bounce an urgent icon.", nick = "urgent-bounce-time")]
			public int UrgentBounceTime { get; set; }
			[Description (blurb = "The hue-shift (-180 to 180) of the urgent indicator color.", nick = "urgent-hue-shift")]
			public int UrgentHueShift { get; set; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class DrawingService : GLib.Object {
			public static Gdk.Pixbuf ar_scale (Gdk.Pixbuf source, int width, int height);
			public static Plank.Drawing.Color average_color (Gdk.Pixbuf source);
			public static string? get_icon_from_file (GLib.File file);
			public static string? get_icon_from_gicon (GLib.Icon? icon);
			public static Gdk.Pixbuf load_icon (string names, int width, int height);
		}
		[CCode (cheader_filename = "plank.h")]
		public class HoverTheme : Plank.Drawing.Theme {
			public HoverTheme (string name);
			protected override void reset_properties ();
		}
		[CCode (cheader_filename = "plank.h")]
		public abstract class Theme : Plank.Services.Preferences {
			public const string DEFAULT_NAME;
			public Theme ();
			public void draw_background (Plank.Drawing.DockSurface surface);
			protected void draw_inner_rect (Cairo.Context cr, int width, int height);
			public static void draw_rounded_line (Cairo.Context cr, double x, double y, double width, double height, bool is_round_left, bool is_round_right, Cairo.Pattern? stroke = null, Cairo.Pattern? fill = null);
			public static void draw_rounded_rect (Cairo.Context cr, double x, double y, double width, double height, double top_radius = 6.0, double bottom_radius = 6.0, double line_width = 1.0);
			public int get_bottom_offset ();
			public static GLib.File? get_theme_folder (string name);
			public static Gee.ArrayList<string> get_theme_list ();
			public int get_top_offset ();
			public void load (string type);
			protected override void reset_properties ();
			protected override void verify (string prop);
			public Theme.with_name (string name);
			[Description (blurb = "The roundness of the bottom corners.", nick = "bottom-roundness")]
			public int BottomRoundness { get; set; }
			[Description (blurb = "The ending color (RGBA) of the fill gradient.", nick = "fill-end-color")]
			public Plank.Drawing.Color FillEndColor { get; set; }
			[Description (blurb = "The starting color (RGBA) of the fill gradient.", nick = "fill-start-color")]
			public Plank.Drawing.Color FillStartColor { get; set; }
			[Description (blurb = "The color (RGBA) of the inner stroke.", nick = "inner-stroke-color")]
			public Plank.Drawing.Color InnerStrokeColor { get; set; }
			[Description (blurb = "The thickness (in pixels) of lines drawn.", nick = "line-width")]
			public int LineWidth { get; set; }
			[Description (blurb = "The color (RGBA) of the outer stroke.", nick = "outer-stroke-color")]
			public Plank.Drawing.Color OuterStrokeColor { get; set; }
			[Description (blurb = "The roundness of the top corners.", nick = "top-roundness")]
			public int TopRoundness { get; set; }
		}
		[CCode (cheader_filename = "plank.h")]
		public struct Color {
			public double R;
			public double G;
			public double B;
			public double A;
			public void add_hue (double val);
			public void brighten_val (double amount);
			public void darken_by_sat (double amount);
			public void darken_val (double amount);
			public bool equal (Plank.Drawing.Color color);
			public static Plank.Drawing.Color from_gdk_color (Gdk.Color color);
			public static Plank.Drawing.Color from_gdk_rgba (Gdk.RGBA color);
			public static Plank.Drawing.Color from_string (string s);
			public void get_hsv (out double h, out double s, out double v);
			public double get_hue ();
			public double get_sat ();
			public double get_val ();
			public void multiply_sat (double amount);
			public void set_alpha (double alpha);
			public void set_hsv (double h, double s, double v);
			public void set_hue (double hue);
			public void set_max_sat (double sat);
			public void set_max_val (double val);
			public void set_min_sat (double sat);
			public void set_min_value (double val);
			public void set_sat (double sat);
			public void set_val (double val);
			public Gdk.Color to_gdk_color ();
			public Gdk.RGBA to_gdk_rgba ();
			public string to_string ();
		}
	}
	namespace Factories {
		[CCode (cheader_filename = "plank.h")]
		public abstract class AbstractMain : GLib.Object {
			protected static bool DEBUG;
			protected static bool VERBOSE;
			protected string[] about_artists;
			protected string[] about_authors;
			protected static Gtk.AboutDialog? about_dlg;
			protected string[] about_documenters;
			protected string about_translators;
			protected string app_copyright;
			protected string app_dbus;
			protected string app_icon;
			public string app_launcher;
			protected Gtk.Application application;
			protected string build_data_dir;
			protected string build_pkg_data_dir;
			protected string build_release_name;
			protected string build_version;
			protected string build_version_info;
			public static string dock_path;
			protected string exec_name;
			protected string help_url;
			protected string main_url;
			protected string program_name;
			protected string translate_url;
			protected const GLib.OptionEntry[] options;
			public AbstractMain ();
			protected virtual void create_controller ();
			public virtual void help ();
			protected virtual bool initialize_libraries (ref unowned string[] args);
			protected virtual void initialize_program ();
			protected virtual void initialize_services ();
			public bool is_launcher_for_dock (string launcher);
			public virtual void on_item_clicked ();
			protected virtual bool parse_commandline (ref unowned string[] args);
			public virtual void quit ();
			public virtual int run (ref unowned string[] args);
			protected virtual void set_options ();
			public virtual void show_about ();
			public virtual void translate ();
			protected signal void initialized ();
		}
		[CCode (cheader_filename = "plank.h")]
		public class Factory : GLib.Object {
			public static Plank.Factories.ItemFactory item_factory;
			public static Plank.Factories.AbstractMain main;
			public Factory ();
			public static void init (Plank.Factories.AbstractMain main_class, Plank.Factories.ItemFactory item);
		}
		[CCode (cheader_filename = "plank.h")]
		public class ItemFactory : GLib.Object {
			public GLib.File launchers_dir;
			public ItemFactory ();
			protected Plank.Items.DockItem default_make_item (GLib.File file, string launcher);
			protected string get_launcher_from_dockitem (GLib.File file);
			public void make_default_items ();
			public GLib.File? make_dock_item (string uri);
			public virtual Plank.Items.DockItem make_item (GLib.File file);
		}
	}
	namespace Items {
		[CCode (cheader_filename = "plank.h")]
		public class ApplicationDockItem : Plank.Items.DockItem {
			public ApplicationDockItem ();
			public override bool accept_drop (Gee.ArrayList<string> uris);
			public override bool can_accept_drop (Gee.ArrayList<string> uris);
			public override Gee.ArrayList<Gtk.MenuItem> get_menu_items ();
			public string? get_unity_application_uri ();
			public string? get_unity_dbusname ();
			public bool is_running ();
			public bool is_window ();
			protected void load_from_launcher ();
			protected override Plank.Items.ClickAnimation on_clicked (Plank.Items.PopupButton button, Gdk.ModifierType mod);
			protected override void on_scrolled (Gdk.ScrollDirection direction, Gdk.ModifierType mod);
			public static void parse_launcher (string launcher, out string icon, out string text, Gee.ArrayList<string>? actions = null, Gee.Map<string,string>? actions_map = null, Gee.ArrayList<string>? mimes = null);
			public void set_urgent (bool is_urgent);
			public void unity_reset ();
			public void unity_update (string sender_name, GLib.VariantIter prop_iter);
			public ApplicationDockItem.with_dockitem_file (GLib.File file);
			public ApplicationDockItem.with_dockitem_filename (string filename);
			public Bamf.Application? App { internal get; internal set construct; }
			public signal void app_closed ();
			public signal void app_window_added ();
			public signal void app_window_removed ();
			public signal void pin_launcher ();
		}
		[CCode (cheader_filename = "plank.h")]
		public class ApplicationDockItemProvider : Plank.Items.DockItemProvider {
			public ApplicationDockItemProvider (Plank.DockController controller);
			public void add_item_with_uri (string uri, Plank.Items.DockItem? target = null);
			protected override void handle_item_deleted (Plank.Items.DockItem item);
			public bool item_exists_for_uri (string uri);
			protected override void item_signals_connect (Plank.Items.DockItem item);
			protected override void item_signals_disconnect (Plank.Items.DockItem item);
			protected override void update_visible_items ();
			public Plank.DockController controller { get; protected set construct; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockItem : GLib.Object {
			public DockItem ();
			public virtual bool accept_drop (Gee.ArrayList<string> uris);
			public string as_uri ();
			public virtual bool can_accept_drop (Gee.ArrayList<string> uris);
			public virtual bool can_be_removed ();
			public void clicked (Plank.Items.PopupButton button, Gdk.ModifierType mod);
			public void copy_values_to (Plank.Items.DockItem target);
			protected static Gtk.MenuItem create_menu_item (string title, string icon);
			public void @delete ();
			protected virtual void draw_icon (Plank.Drawing.DockSurface surface);
			public unowned Plank.Drawing.DockSurface? get_background_surface (Plank.Items.DrawItemFunc? draw_func = null);
			public unowned Plank.Drawing.DockSurface? get_foreground_surface (Plank.Items.DrawItemFunc? draw_func = null);
			public virtual Gee.ArrayList<Gtk.MenuItem> get_menu_items ();
			public Plank.Drawing.DockSurface get_surface_copy (int width, int height, Plank.Drawing.DockSurface model);
			protected void handle_deleted ();
			protected virtual Plank.Items.ClickAnimation on_clicked (Plank.Items.PopupButton button, Gdk.ModifierType mod);
			protected virtual void on_scrolled (Gdk.ScrollDirection direction, Gdk.ModifierType mod);
			public void reset_buffers ();
			protected void reset_icon_buffer ();
			public void scrolled (Gdk.ScrollDirection direction, Gdk.ModifierType mod);
			public virtual string unique_id ();
			public GLib.DateTime AddTime { get; set; }
			public Plank.Drawing.Color AverageIconColor { get; protected set; }
			public Plank.Items.PopupButton Button { get; protected set; }
			public Plank.Items.ClickAnimation ClickedAnimation { get; protected set; }
			public int64 Count { get; set; }
			public bool CountVisible { get; set; }
			public string DockItemFilename { owned get; }
			protected Gdk.Pixbuf? ForcePixbuf { get; set; }
			public string Icon { get; set; }
			public Plank.Items.IndicatorState Indicator { get; protected set; }
			public bool IsVisible { get; set; }
			public GLib.DateTime LastActive { get; protected set; }
			public GLib.DateTime LastClicked { get; protected set; }
			public GLib.DateTime LastScrolled { get; protected set; }
			public GLib.DateTime LastUrgent { get; protected set; }
			public string Launcher { get; }
			public int Position { get; set; }
			public Plank.Items.DockItemPreferences Prefs { get; construct; }
			public double Progress { get; set; }
			public bool ProgressVisible { get; set; }
			public GLib.DateTime RemoveTime { get; set; }
			public Plank.Items.ItemState State { get; protected set; }
			public string Text { get; set; }
			public virtual bool ValidItem { get; }
			public signal void deleted ();
			public signal void launcher_changed ();
			public signal void needs_redraw ();
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockItemPreferences : Plank.Services.Preferences {
			public DockItemPreferences ();
			protected override void reset_properties ();
			protected override void verify (string prop);
			public DockItemPreferences.with_file (GLib.File file);
			public DockItemPreferences.with_filename (string filename);
			public DockItemPreferences.with_launcher (string launcher);
			[Description (blurb = "The uri for this item.", nick = "launcher")]
			public string Launcher { get; set; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockItemProvider : GLib.Object {
			protected Gee.ArrayList<Plank.Items.DockItem> internal_items;
			protected Gee.Map<Plank.Items.DockItem,int> saved_item_positions;
			protected Gee.ArrayList<Plank.Items.DockItem> visible_items;
			public DockItemProvider ();
			public void add_item (Plank.Items.DockItem item);
			protected virtual void add_item_without_signaling (Plank.Items.DockItem item);
			protected static int compare_items (Plank.Items.DockItem left, Plank.Items.DockItem right);
			protected virtual void handle_item_deleted (Plank.Items.DockItem item);
			protected void handle_item_state_changed ();
			protected void handle_setting_changed ();
			protected virtual void item_signals_connect (Plank.Items.DockItem item);
			protected virtual void item_signals_disconnect (Plank.Items.DockItem item);
			public virtual void move_item_to (Plank.Items.DockItem move, Plank.Items.DockItem target);
			public void remove_item (Plank.Items.DockItem item);
			protected virtual void remove_item_without_signaling (Plank.Items.DockItem item);
			public virtual void replace_item (Plank.Items.DockItem new_item, Plank.Items.DockItem old_item);
			public void reset_item_buffers ();
			public void restore_item_positions ();
			public void save_item_positions ();
			protected void set_item_positions ();
			protected virtual void update_visible_items ();
			public Gee.ArrayList<Plank.Items.DockItem> Items { get; }
			public signal void item_position_changed ();
			public signal void item_state_changed ();
			public signal void items_changed (Gee.List<Plank.Items.DockItem> added, Gee.List<Plank.Items.DockItem> removed);
		}
		[CCode (cheader_filename = "plank.h")]
		public class FileDockItem : Plank.Items.DockItem {
			public FileDockItem ();
			protected override void draw_icon (Plank.Drawing.DockSurface surface);
			public override Gee.ArrayList<Gtk.MenuItem> get_menu_items ();
			public void launch ();
			protected override Plank.Items.ClickAnimation on_clicked (Plank.Items.PopupButton button, Gdk.ModifierType mod);
			public FileDockItem.with_dockitem_file (GLib.File file);
			public FileDockItem.with_dockitem_filename (string filename);
		}
		[CCode (cheader_filename = "plank.h")]
		public class PlankDockItem : Plank.Items.ApplicationDockItem {
			public PlankDockItem ();
			public override Gee.ArrayList<Gtk.MenuItem> get_menu_items ();
			public static Gee.ArrayList<Gtk.MenuItem> get_plank_menu_items ();
			protected override Plank.Items.ClickAnimation on_clicked (Plank.Items.PopupButton button, Gdk.ModifierType mod);
			public PlankDockItem.with_dockitem_file (GLib.File file);
			public PlankDockItem.with_dockitem_filename (string filename);
		}
		[CCode (cheader_filename = "plank.h")]
		public class TransientDockItem : Plank.Items.ApplicationDockItem {
			public TransientDockItem ();
			public override bool can_be_removed ();
			public TransientDockItem.with_launcher (string launcher_uri);
		}
		[CCode (cheader_filename = "plank.h")]
		public enum ClickAnimation {
			NONE,
			BOUNCE,
			DARKEN,
			LIGHTEN
		}
		[CCode (cheader_filename = "plank.h")]
		public enum IndicatorState {
			NONE,
			SINGLE,
			SINGLE_PLUS
		}
		[CCode (cheader_filename = "plank.h")]
		[Flags]
		public enum ItemState {
			NORMAL,
			ACTIVE,
			URGENT
		}
		[CCode (cheader_filename = "plank.h")]
		[Flags]
		public enum PopupButton {
			NONE,
			LEFT,
			MIDDLE,
			RIGHT;
			public static Plank.Items.PopupButton from_event_button (Gdk.EventButton event);
		}
		[CCode (cheader_filename = "plank.h")]
		public delegate Plank.Drawing.DockSurface DrawItemFunc (Plank.Items.DockItem item, Plank.Drawing.DockSurface source, Plank.Drawing.DockSurface? target);
	}
	namespace Services {
		[CCode (cheader_filename = "plank.h")]
		public class Logger : GLib.Object {
			public static void initialize (string app_name);
			public static void notification (string msg, string icon = "");
			public static void verbose (string msg, ...);
			public static Plank.Services.LogLevel DisplayLevel { get; set; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class Paths : GLib.Object {
			public static bool ensure_directory_exists (GLib.File dir);
			public static void initialize (string app_name, string data_folder);
			public static GLib.File AppCacheFolder { get; protected set; }
			public static GLib.File AppConfigFolder { get; protected set; }
			public static GLib.File AppDataFolder { get; protected set; }
			public static GLib.File AppThemeFolder { get; protected set; }
			public static GLib.File CacheHomeFolder { get; protected set; }
			public static GLib.File ConfigHomeFolder { get; protected set; }
			public static Gee.ArrayList<GLib.File> DataDirFolders { get; protected set; }
			public static GLib.File DataFolder { get; protected set; }
			public static GLib.File DataHomeFolder { get; protected set; }
			public static GLib.File HomeFolder { get; protected set; }
			public static GLib.File ThemeFolder { get; protected set; }
		}
		[CCode (cheader_filename = "plank.h")]
		public abstract class Preferences : GLib.Object {
			public Preferences ();
			public void apply ();
			public void delay ();
			public void @delete ();
			public string get_filename ();
			protected void init_from_file (GLib.File file);
			protected void init_from_filename (string filename);
			protected abstract void reset_properties ();
			protected virtual void verify (string prop);
			public Preferences.with_file (GLib.File file);
			public Preferences.with_filename (string filename);
			[Signal (action = true, detailed = true, no_hooks = true, no_recurse = true, run = "first")]
			public signal void changed ();
			public signal void deleted ();
		}
		[CCode (cheader_filename = "plank.h")]
		public class System : GLib.Object {
			public static void launch (GLib.File app);
			public static void launch_with_files (GLib.File? app, GLib.File[] files);
			public static void open (GLib.File file);
			public static void open_files (GLib.File[] files);
			public static void open_uri (string uri);
		}
		[CCode (cheader_filename = "plank.h")]
		public interface PrefsSerializable : GLib.Object {
			public abstract void prefs_deserialize (string s);
			public abstract string prefs_serialize ();
		}
		[CCode (cheader_filename = "plank.h")]
		public enum LogLevel {
			VERBOSE,
			DEBUG,
			INFO,
			NOTIFY,
			WARN,
			ERROR,
			FATAL
		}
	}
	namespace Widgets {
		[CCode (cheader_filename = "plank.h")]
		public class CompositedWindow : Gtk.Window {
			public CompositedWindow ();
			public override bool draw (Cairo.Context cr);
			public CompositedWindow.with_type (Gtk.WindowType window_type);
		}
		[CCode (cheader_filename = "plank.h")]
		public class DockWindow : Plank.Widgets.CompositedWindow {
			protected Gtk.Menu? menu;
			public DockWindow (Plank.DockController controller);
			public override bool button_press_event (Gdk.EventButton event);
			public override bool button_release_event (Gdk.EventButton event);
			protected void drag_item_changed ();
			public override bool draw (Cairo.Context cr);
			public override bool enter_notify_event (Gdk.EventCrossing event);
			public override bool leave_notify_event (Gdk.EventCrossing event);
			public override bool map_event (Gdk.EventAny event);
			public bool menu_is_visible ();
			public override bool motion_notify_event (Gdk.EventMotion event);
			protected void on_menu_hide ();
			protected void on_menu_show ();
			protected void position_hover ();
			protected void position_menu (Gtk.Menu menu, out int x, out int y, out bool push_in);
			public override bool scroll_event (Gdk.EventScroll event);
			protected void set_hovered (Plank.Items.DockItem? item);
			protected void show_menu (uint button, bool show_plank_menu);
			public bool update_hovered (int x, int y);
			public void update_icon_regions ();
			public void update_size_and_position ();
			public Plank.Items.DockItem? HoveredItem { get; protected set; }
			public Plank.DockController controller { private get; construct; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class HoverWindow : Plank.Widgets.CompositedWindow {
			public HoverWindow (Plank.DockController controller);
			public override bool draw (Cairo.Context cr);
			public void move_hover (int item_x, int item_y);
			public string Text { get; set; }
			public Plank.DockController controller { private get; construct; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class PoofWindow : Plank.Widgets.CompositedWindow {
			public PoofWindow (int x, int y);
			public override bool draw (Cairo.Context cr);
			public void run ();
			public int x { private get; construct; }
			public int y { private get; construct; }
		}
		[CCode (cheader_filename = "plank.h")]
		public class TitledSeparatorMenuItem : Gtk.SeparatorMenuItem {
			public TitledSeparatorMenuItem (string text);
			protected override bool draw (Cairo.Context cr);
			public TitledSeparatorMenuItem.no_line (string text);
		}
	}
	[CCode (cheader_filename = "plank.h")]
	public class DockController : GLib.Object {
		public Plank.DragManager drag_manager;
		public Plank.HideManager hide_manager;
		public Plank.Widgets.HoverWindow hover;
		public Plank.Items.ApplicationDockItemProvider items;
		public Plank.PositionManager position_manager;
		public Plank.DockPreferences prefs;
		public Plank.DockRenderer renderer;
		public Plank.Widgets.DockWindow window;
		public DockController ();
	}
	[CCode (cheader_filename = "plank.h")]
	public class DockPreferences : Plank.Services.Preferences {
		public DockPreferences ();
		public void decrease_icon_size ();
		public int get_monitor ();
		public void increase_icon_size ();
		public bool is_horizontal_dock ();
		protected override void reset_properties ();
		protected override void verify (string prop);
		public DockPreferences.with_filename (string filename);
		[Description (blurb = "The alignment for the dock on the monitor's edge.", nick = "alignment")]
		public Gtk.Align Alignment { get; set; }
		[Description (blurb = "Whether to show only windows of the current workspace.", nick = "current-workspace-only")]
		public bool CurrentWorkspaceOnly { get; set; }
		[Description (blurb = "List of *.dockitem files on this dock. DO NOT MODIFY", nick = "dock-items")]
		public string DockItems { get; set; }
		[Description (blurb = "If 0, the dock won't hide.  If 1, the dock intelligently hides.  If 2, the dock auto-hides.", nick = "hide-mode")]
		public Plank.HideType HideMode { get; set; }
		[Description (blurb = "The size of dock icons (in pixels).", nick = "icon-size")]
		public int IconSize { get; set; }
		[Description (blurb = "The alignment of the items in this dock.", nick = "items-alignment")]
		public Gtk.Align ItemsAlignment { get; set; }
		[Description (blurb = "The monitor number for the dock. Use -1 to keep on the primary monitor.", nick = "monitor")]
		public int Monitor { get; set; }
		[Description (blurb = "The dock's position offset from center (in percent).", nick = "offset")]
		public int Offset { get; set; }
		[Description (blurb = "The position for the dock on the monitor.", nick = "position")]
		public Gtk.PositionType Position { get; set; }
		[Description (blurb = "The name of the dock's theme to use.", nick = "theme")]
		public string Theme { get; set; }
		[Description (blurb = "Time (in ms) to wait before unhiding the dock.", nick = "unhide-delay")]
		public uint UnhideDelay { get; set; }
	}
	[CCode (cheader_filename = "plank.h")]
	public class DockRenderer : Plank.Drawing.AnimatedRenderer {
		public DockRenderer (Plank.DockController controller);
		protected override bool animation_needed (GLib.DateTime render_time);
		public void draw_dock (Cairo.Context cr);
		public double get_hide_offset ();
		public void hide ();
		public void initialize ();
		public void reset_buffers ();
		public void show ();
		public bool Hidden { get; private set; }
		public Plank.DockController controller { private get; construct; }
	}
	[CCode (cheader_filename = "plank.h")]
	public class DragManager : GLib.Object {
		public DragManager (Plank.DockController controller);
		public bool drop_is_accepted_by (Plank.Items.DockItem item);
		public void ensure_proxy ();
		public void initialize ();
		public bool DragIsDesktopFile { get; private set; }
		public Plank.Items.DockItem? DragItem { get; private set; }
		public bool ExternalDragActive { get; private set; }
		public bool HoveredAcceptsDrop { get; private set; }
		public bool InternalDragActive { get; private set; }
		public bool RepositionMode { get; private set; }
		public Plank.DockController controller { private get; construct; }
	}
	[CCode (cheader_filename = "plank.h")]
	public class HideManager : GLib.Object {
		public HideManager (Plank.DockController controller);
		public void initialize ();
		public void update_dock_hovered ();
		public bool Disabled { get; set; }
		public bool DockHovered { get; set; }
		public Plank.DockController controller { private get; construct; }
	}
	[CCode (cheader_filename = "plank.h")]
	public class PositionManager : GLib.Object {
		public PositionManager (Plank.DockController controller);
		public Gdk.Rectangle get_background_region ();
		public Gdk.Rectangle get_cursor_region ();
		public void get_dock_draw_position (out int x, out int y);
		public void get_hover_position (Plank.Items.DockItem hovered, out int x, out int y);
		public Gdk.Rectangle get_icon_geometry (Plank.Items.ApplicationDockItem item, bool for_hidden);
		public void get_menu_position (Plank.Items.DockItem hovered, Gtk.Requisition requisition, out int x, out int y);
		public Gdk.Rectangle get_static_dock_region ();
		public void get_struts (ref ulong[] struts);
		public void get_urgent_glow_position (Plank.Items.DockItem item, out int x, out int y);
		public void initialize ();
		public Gdk.Rectangle item_background_region (Gdk.Rectangle rect);
		public Gdk.Rectangle item_draw_region (Gdk.Rectangle hover_rect);
		public Gdk.Rectangle item_hover_region (Plank.Items.DockItem item);
		public void reset_caches (Plank.Drawing.DockTheme theme);
		public void update_dock_position ();
		public void update_regions ();
		public int BottomPadding { get; private set; }
		public int DockBackgroundHeight { get; private set; }
		public int DockBackgroundWidth { get; private set; }
		public int DockHeight { get; private set; }
		public int DockWidth { get; private set; }
		public int GlowSize { get; private set; }
		public int HorizPadding { get; private set; }
		public int IconShadowSize { get; private set; }
		public int IconSize { get; private set; }
		public int IndicatorSize { get; private set; }
		public int ItemPadding { get; private set; }
		public int LineWidth { get; private set; }
		public int MaxItemCount { get; private set; }
		public int TopPadding { get; private set; }
		public int UrgentBounceHeight { get; private set; }
		public int VisibleDockHeight { get; private set; }
		public int VisibleDockWidth { get; private set; }
		public Plank.DockController controller { private get; construct; }
		public int win_x { get; protected set; }
		public int win_y { get; protected set; }
	}
	[CCode (cheader_filename = "plank.h")]
	public enum HideType {
		NONE,
		INTELLIGENT,
		AUTO
	}
	[CCode (cheader_filename = "plank.h")]
	public const string G_RESOURCE_PATH;
}
